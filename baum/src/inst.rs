use alloc::vec::Vec;

use crate::decl_types;
use crate::DataId;
use crate::ElemId;
use crate::FuncId;
use crate::GlobalId;
use crate::LabelId;
use crate::LocalId;
use crate::NumType;
use crate::RefType;
use crate::TableId;
use crate::TypeId;
use crate::ValType;
use crate::VecType;

// Good resource: https://developer.mozilla.org/en-US/docs/WebAssembly/Reference/
// https://pengowray.github.io/wasm-ops/
decl_types! {
    Sign => :enum {
        U,
        S,
    },
    Bits => :enum {
        _64,
        _32,
    },
    IShape => :enum {
        I8X16,
        I16X8,
        I32X4,
        I64X2,
    },
    FShape => :enum {
        F32X4,
        F64X2,
    },
    Shape => :enum {
        I(IShape),
        F(FShape),
    },
    Half => :enum {
        Low,
        High,
    },
    MemArg => {
        offset: u32,
        align: u32,
    },
    Size => :enum {
        _8,
        _16,
        _32,
        _64,
    },
    BlockType => :enum {
        Type(TypeId),
        Val(Option<ValType>),
    },
    End => :(),
    Inst => :enum {
        Const(NumType),

        // Unops
        IClz(Bits),
        ICtz(Bits),
        IPopCnt(Bits),

        FAbs(Bits),
        FNeg(Bits),
        FSqrt(Bits),
        FCeil(Bits),
        FFloor(Bits),
        FTrunc(Bits),
        FNearest(Bits),

        // Binops
        IAdd(Bits),
        ISub(Bits),
        IMul(Bits),
        IDiv(Bits, Sign),
        IRem(Bits, Sign),
        IAnd(Bits),
        IOr(Bits),
        IXor(Bits),
        IShl(Bits),
        IShr(Bits, Sign),
        IRotl(Bits),
        IRotr(Bits),

        FAdd(Bits),
        FSub(Bits),
        FMul(Bits),
        FDiv(Bits),
        Fmin(Bits),
        FMax(Bits),
        FCopySign(Bits),

        // itestop
        IEqz(Bits),

        // irelop
        IEq(Bits),
        INe(Bits),
        ILt(Bits, Sign),
        IGt(Bits, Sign),
        ILe(Bits, Sign),
        IGe(Bits, Sign),

        // frelop
        FEq(Bits),
        FNe(Bits),
        FLt(Bits),
        FGt(Bits),
        FLe(Bits),
        FGe(Bits),

        IExtend8S(Bits),
        IExtend16S(Bits),
        I64Extend32S(Bits),
        I32WrapI64(Bits),
        /// Unlike the other Extend operations, they assume that they are extending from T -> T where T maybe i32 or i64
        /// Wasm only has i32 & i64, so bytes will be represented as i32
        /// This will perform I64 -> I32
        I64ExtendI32(Sign),

        Trunc(Bits, Bits, Sign),
        TruncSat(Bits, Bits, Sign),
        F32DemoteF64,
        F64PromoteF32,

        FConvertI(Bits, Bits, Sign),
        IReinterpretF(Bits, Bits),
        FReinterpretI(Bits, Bits),

        // Vector instrunctions
        VConst(VecType),
        VNot,
        VAnd,
        VAndNot,
        VOr,
        VXor,
        VBitSelect,
        VAnyTrue,

        VI8X16Shuffle([u8; 16]),
        VI8X16Swizzle,
        VSplat(Shape),
        VI8X16ExtractLane(Bits, u8),
        VI16X8ExtractLane(Bits, u8),
        VI32X4ExtractLine(u8),
        VI64X2ExtractLine(u8),
        VExtractLane(FShape, u8),
        VReplaceLane(Shape, u8),
        VI8X16Eq,
        VI8X16Ne,
        VI8X16Lt(Sign),
        VI8X16Gt(Sign),
        VI8X16Le(Sign),
        VI8X16Ge(Sign),
        VI16X8Eq,
        VI16X8Ne,
        VI16X8Lt(Sign),
        VI16X8Gt(Sign),
        VI16X8Le(Sign),
        VI16X8Ge(Sign),
        VI32X4Eq,
        VI32X4Ne,
        VI32X4Lt(Sign),
        VI32X4Gt(Sign),
        VI32X4Le(Sign),
        VI32X4Ge(Sign),
        VI64X2Eq,
        VI64X2Ne,
        VI64X2Lt,
        VI64X2Gt,
        VI64X2Le,
        VI64X2Ge,
        VFEq(FShape),
        VFNe(FShape),
        VFLt(FShape),
        VFGt(FShape),
        VFLe(FShape),
        VFGe(FShape),
        VIAbs(IShape),
        VINeg(IShape),
        VI8X16PopCnt,
        VI16X8Q15MulRSatS,
        VI32X4DotI16X8S,
        VFAbs(FShape),
        VFNeg(FShape),
        VFSqrt(FShape),
        VFCeil(FShape),
        VFFloor(FShape),
        VFTrunc(FShape),
        VFNearest(FShape),
        VIAllTrue(IShape),
        VIBitMask(IShape),
        VI8X16NarrowI16X8(Sign),
        VI16X8NarrowI32X4(Sign),
        VI16x8ExtendI8X16(Half, Sign),
        VI32X4ExtendI16X8(Half, Sign),
        VI64X2ExtendI32X4(Half, Sign),
        VIShl(IShape),
        VIShr(IShape, Sign),
        VIAdd(IShape),
        VISub(IShape),
        VI8X16Min(Sign),
        VI8X16Max(Sign),
        VI16X8Min(Sign),
        VI16X8Max(Sign),
        VI32X4Min(Sign),
        VI32X4Max(Sign),
        VI8X16AddSat(Sign),
        VI8X16SubSat(Sign),
        VI16X8AddSat(Sign),
        VI16X8SubSat(Sign),
        VI16X8Mul,
        VI32X4Mul,
        VI64X2Mul,
        VI8X16AvgrU,
        VI16X8AvgrU,
        VI16X8ExtMulI8X16(Half, Sign),
        VI32X4ExtMulI16X8(Half, Sign),
        VI64X2ExtMulI32X4(Half, Sign),
        VI16X8ExtAddPairwiseI8X16(Sign),
        VI32X4ExtADdPairwiseI16X8(Sign),
        VFAdd(FShape),
        VFSub(FShape),
        VFMul(FShape),
        VFDiv(FShape),
        VFMin(FShape),
        VFMax(FShape),
        VFPMin(FShape),
        VFPMax(FShape),
        I32X4TruncSatF32X4(Sign),
        I32X4TruncSatF64X2Zero(Sign),
        F32X4ConvertI32X4(Sign),
        F32X4DemoteF64X2Zero,
        F64X2ConvertLowI32X4(Sign),
        F64X2PromoteLowF32X4,

        RefNull(RefType),
        RefIsNull,
        RefFunc(FuncId),

        Drop,
        Select(Option<Vec<ValType>>),

        LocalGet(LocalId),
        LocalSet(LocalId),
        LocalTee(LocalId),

        GlobalGet(GlobalId),
        GlobalSet(GlobalId),

        TableGet(TableId),
        TableSet(TableId),
        TableSize(TableId),
        TableGrow(TableId),
        TableFill(TableId),
        TableCopy(TableId, TableId),
        TableInit(TableId, ElemId),
        ElemDrop(ElemId),

        ILoad(Bits, MemArg),
        FLoad(Bits, MemArg),
        VLoad(MemArg),
        IStore(Bits, MemArg),
        FStore(Bits, MemArg),
        VStore(MemArg),
        ILoad8(Bits, Sign, MemArg),
        ILoad16(Bits, Sign, MemArg),
        I64Load32(Sign, MemArg),
        VLoad8X8(Sign, MemArg),
        VLoad16X4(Sign, MemArg),
        VLoad32X2(Sign, MemArg),
        VLoad32Zero(MemArg),
        VLoad64Zero(MemArg),
        VLoadSplat(Size, MemArg),
        VLoadLane(Size, MemArg, u8),
        VStoreLane(Size, MemArg, u8),
        MemSize,
        MemGrow,
        MemFill,
        MemCopy,
        MemInit(DataId),
        DataDrop(DataId),

        IAtomicLoad(Bits, MemArg),
        IAtomicStore(Bits, MemArg),
        IAtomicLoad8u(Bits, MemArg),
        IAtomicLoad16u(Bits, MemArg),
        I64AtomicLoad32u(MemArg),
        IAtomicStore8(Bits, MemArg),
        IAtomicStore16(Bits, MemArg),
        I64AtomicStore32(MemArg),
        IAtomicRMW8AddU(Bits, MemArg),
        IAtomicRMW8SubU(Bits, MemArg),
        IAtomicRMW8AndU(Bits, MemArg),
        IAtomicRMW8OrU(Bits, MemArg),
        IAtomicRMW8XorU(Bits, MemArg),
        IAtomicRMW8XchgU(Bits, MemArg),
        IAtomicRMW16AddU(Bits, MemArg),
        IAtomicRMW16SubU(Bits, MemArg),
        IAtomicRMW16AndU(Bits, MemArg),
        IAtomicRMW16OrU(Bits, MemArg),
        IAtomicRMW16XorU(Bits, MemArg),
        IAtomicRMW16XchgU(Bits, MemArg),
        I64AtomicRMW32AddU(MemArg),
        I64AtomicRMW32SubU(MemArg),
        I64AtomicRMW32AndU(MemArg),
        I64AtomicRMW32OrU(MemArg),
        I64AtomicRMW32XorU(MemArg),
        I64AtomicRMW32XchgU(MemArg),
        IAtomicRmwCmpXchng(Bits, MemArg),
        IAtomicRmw8CmpXchng(Bits, MemArg),
        IAtomicRmw16CmpXchng(Bits, MemArg),
        I64AtomicRmw32CmpXchng(MemArg),
        MemAtomicNotify(MemArg),
        MemAtomicWait(Bits, MemArg),
        AtomicFence,

        Nop,
        Unreachable,
        Block(BlockType, Vec<Inst>, End),
        Loop(BlockType, Vec<Inst>, End),
        If(BlockType, Vec<Inst>, Vec<Inst>, End),
        Br(LabelId),
        BrIf(LabelId),
        BrTable(LabelId),
        Return,
        Call(FuncId),
        CallIndirect(FuncId),
    },
}
